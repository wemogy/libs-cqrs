"use strict";(self.webpackChunkwemogy=self.webpackChunkwemogy||[]).push([[726],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return h}});var a=t(7294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function m(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var l=a.createContext({}),s=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):m(m({},n),e)),t},d=function(e){var n=s(e.components);return a.createElement(l.Provider,{value:n},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),c=s(t),p=o,h=c["".concat(l,".").concat(p)]||c[p]||u[p]||r;return t?a.createElement(h,m(m({ref:n},d),{},{components:t})):a.createElement(h,m({ref:n},d))}));function h(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var r=t.length,m=new Array(r);m[0]=p;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i[c]="string"==typeof e?e:o,m[1]=i;for(var s=2;s<r;s++)m[s]=t[s];return a.createElement.apply(null,m)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},1941:function(e,n,t){t.r(n),t.d(n,{assets:function(){return l},contentTitle:function(){return m},default:function(){return u},frontMatter:function(){return r},metadata:function(){return i},toc:function(){return s}});var a=t(3117),o=(t(7294),t(3905));const r={},m="Commands",i={unversionedId:"commands",id:"commands",title:"Commands",description:"Introduction",source:"@site/docs-general/02-commands.md",sourceDirName:".",slug:"/commands",permalink:"/commands",draft:!1,editUrl:"https://github.com/wemogy/libs-cqrs/edit/main/docs-general/02-commands.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Overview",permalink:"/"},next:{title:"Delayed commands",permalink:"/delayed-commands"}},l={},s=[{value:"Introduction",id:"introduction",level:2},{value:"Hello world sample",id:"hello-world-sample",level:3},{value:"The Command model",id:"the-command-model",level:4},{value:"The Command handler",id:"the-command-handler",level:4},{value:"Registering the command",id:"registering-the-command",level:4},{value:"Executing the command",id:"executing-the-command",level:4},{value:"How it works",id:"how-it-works",level:2},{value:"Execution pipeline",id:"execution-pipeline",level:3},{value:"Command definition",id:"command-definition",level:2},{value:"Command with a result",id:"command-with-a-result",level:3},{value:"Command without result",id:"command-without-result",level:3},{value:"Command handling",id:"command-handling",level:2},{value:"Handle command with result",id:"handle-command-with-result",level:3},{value:"Handle command without result",id:"handle-command-without-result",level:3},{value:"Command validation",id:"command-validation",level:2},{value:"Custom implementation",id:"custom-implementation",level:3},{value:"FluentValidation",id:"fluentvalidation",level:3},{value:"Command authorization",id:"command-authorization",level:2},{value:"Command pre-processing",id:"command-pre-processing",level:2},{value:"Command post-processing",id:"command-post-processing",level:2},{value:"Post-process command with result",id:"post-process-command-with-result",level:3},{value:"Post-process command without result",id:"post-process-command-without-result",level:3}],d={toc:s},c="wrapper";function u(e){let{components:n,...t}=e;return(0,o.kt)(c,(0,a.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"commands"},"Commands"),(0,o.kt)("h2",{id:"introduction"},"Introduction"),(0,o.kt)("p",null,"TBD..."),(0,o.kt)("h3",{id:"hello-world-sample"},"Hello world sample"),(0,o.kt)("p",null,"In this little sample of ",(0,o.kt)("inlineCode",{parentName:"p"},"Wemogy.CQRS")," we will implement a command without parameters with the belonging command handler. Moreover we will register ",(0,o.kt)("inlineCode",{parentName:"p"},"wemogy.CQRS")," in the dependency injection and finally execute the command to print a ",(0,o.kt)("inlineCode",{parentName:"p"},"Hello World!")," on the console."),(0,o.kt)("h4",{id:"the-command-model"},"The Command model"),(0,o.kt)("p",null,"For each command its required to create a model of the command itself, which contains all information which are required to execute the command."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"using Wemogy.CQRS.Commands.Abstractions;\n\npublic class HelloWorldCommand : ICommand\n{\n}\n")),(0,o.kt)("h4",{id:"the-command-handler"},"The Command handler"),(0,o.kt)("p",null,"The second mandatory implementation for a command is a command handler, which contains the actual implementation of the command action."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},'using System.Threading.Tasks;\nusing Wemogy.CQRS.Commands.Abstractions;\nusing Wemogy.CQRS.Commands.Structs;\n\npublic class HelloWorldCommandHandler : ICommandHandler<HelloWorldCommand>\n{\n  public Task HandleAsync(HelloWorldCommand command)\n  {\n    Console.WriteLine("Hello world!");\n    return Task.CompletedTask;\n  }\n}\n')),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"The ",(0,o.kt)("inlineCode",{parentName:"p"},"Void")," type comes from ",(0,o.kt)("inlineCode",{parentName:"p"},"Wemogy.CQRS.Commands.Structs")," and is used to describe a ",(0,o.kt)("strong",{parentName:"p"},"generic")," task without a result to return.")),(0,o.kt)("h4",{id:"registering-the-command"},"Registering the command"),(0,o.kt)("p",null,"It's required to execute ",(0,o.kt)("inlineCode",{parentName:"p"},"services.AddCQRS();")," in your dependency injection file of the assembly which contains the commands. In addition its also supported to pass one or multiple assemblies to the ",(0,o.kt)("inlineCode",{parentName:"p"},"AddCQRS()")," extension method, in case that you need to call it from another assembly."),(0,o.kt)("h4",{id:"executing-the-command"},"Executing the command"),(0,o.kt)("p",null,"This sample is part of a .NET Core controller class."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"using Wemogy.CQRS.Commands.Abstractions;\n\npublic class HelloWorldController : ControllerBase\n{\n  private readonly ICommands _commands;\n\n  public HelloWorldController(ICommands commands)\n  {\n    _commands = commands;\n  }\n\n  [HttpGet]\n  public async Task<ActionResult> SayHelloWorld()\n  {\n    // creating the command with all required information\n    var helloWorldCommand = new HelloWorldCommand();\n\n    // executing the command though the ICommands mediator\n    await _commands.RunAsync(helloWorldCommand);\n\n    return Ok();\n  }\n}\n")),(0,o.kt)("h2",{id:"how-it-works"},"How it works"),(0,o.kt)("h3",{id:"execution-pipeline"},"Execution pipeline"),(0,o.kt)("p",null,"All commands are sent though the ",(0,o.kt)("inlineCode",{parentName:"p"},"ICommands")," interface (mediator). They all will be processed in the same defined order:"),(0,o.kt)("mermaid",{value:'flowchart TB\n  subgraph "Optional pre-processing"\n    CommandValidator --\x3e CommandAuthorization\n    CommandAuthorization --\x3e CommandPreProcessor\n  end\n  CommandPreProcessor --\x3e CommandHandler\n  CommandHandler --\x3e CommandPostProcessor\n  subgraph "Optional post-processing"\n    CommandPostProcessor\n  end'}),(0,o.kt)("admonition",{title:"Convention",type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Place the command, the command-handler and all belonging handlers (like pre-processor) in the same folder:"),(0,o.kt)("ul",{parentName:"admonition"},(0,o.kt)("li",{parentName:"ul"},"Commands/",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"CreateUser/",(0,o.kt)("ul",{parentName:"li"},(0,o.kt)("li",{parentName:"ul"},"CreateUserCommand.cs"),(0,o.kt)("li",{parentName:"ul"},"CreateUserCommandHandler.cs"),(0,o.kt)("li",{parentName:"ul"},"CreateUserCommandPreProcessor.cs"))))))),(0,o.kt)("h2",{id:"command-definition"},"Command definition"),(0,o.kt)("p",null,"If you want to create a new command, you need to create a class, which implements a variation of the ",(0,o.kt)("inlineCode",{parentName:"p"},"ICommand")," interface."),(0,o.kt)("h3",{id:"command-with-a-result"},"Command with a result"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"public class CreateUserCommand : ICommand<User>\n{\n    public Guid Id { get; set; }\n\n    public string Firstname { get; set; }\n\n    public CreateUserCommand()\n    {\n        Firstname = string.Empty;\n    }\n}\n")),(0,o.kt)("h3",{id:"command-without-result"},"Command without result"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"public class NotifyUserCommand : ICommand\n{\n    public Guid UserId { get; set; }\n\n    public string Message { get; set; }\n\n    public CreateUserCommand()\n    {\n        Message = string.Empty;\n    }\n}\n")),(0,o.kt)("h2",{id:"command-handling"},"Command handling"),(0,o.kt)("h3",{id:"handle-command-with-result"},"Handle command with result"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"public class CreateUserCommandHandler : ICommandHandler<CreateUserCommand, User>\n{\n  private readonly IUserRepository _userRepository;\n\n  public CreateUserCommandHandler(IUserRepository userRepository)\n  {\n    _userRepository = userRepository;\n  }\n\n  public Task<User> HandleAsync(CreateUserCommand command)\n  {\n    // map the command to an entity\n    var user = command.Adapt<User>(command);\n\n    // create the user\n    return _userRepository.CreateAsync(user);\n  }\n}\n")),(0,o.kt)("h3",{id:"handle-command-without-result"},"Handle command without result"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"public class NotifyUserCommandHandler : ICommandHandler<NotifyUserCommand>\n{\n  private readonly INotificationService _notificationService;\n\n  public NotifyUserCommandHandler(INotificationService notificationService)\n  {\n    _notificationService = notificationService;\n  }\n\n  public Task HandleAsync(NotifyUserCommand command)\n  {\n    return _notificationService.SendAsync(command.UserId, command.Message);\n  }\n}\n")),(0,o.kt)("h2",{id:"command-validation"},"Command validation"),(0,o.kt)("p",null,"The command validation step can be used to validate, if all properties of a command have valid values. Moreover it's possible to execute some asynchronous logic, like an API call, to verify if the command is a valid one."),(0,o.kt)("p",null,"All you need to do, is placing one of the following implementation types next to the command model. The CQRS library, will scan the assembly of the command to get all implementations of ",(0,o.kt)("inlineCode",{parentName:"p"},"ICommandValidator<CreateUserCommand>")," and call it when running the ",(0,o.kt)("a",{parentName:"p",href:"#execution-pipeline"},"execution pipeline"),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"FluentValidationCommandValidator<TCommand>")," also implements this interface."),(0,o.kt)("h3",{id:"custom-implementation"},"Custom implementation"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"public class CreateUserCommandValidator : ICommandValidator<CreateUserCommand>\n{\n  public Task ValidateAsync(CreateUserCommand command)\n  {\n    // ToDo: custom validation logic goes here\n  }\n}\n")),(0,o.kt)("h3",{id:"fluentvalidation"},"FluentValidation"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"public class CreateUserCommandValidator : FluentValidationCommandValidator<CreateUserCommand>\n{\n  public CreateUserCommandValidator()\n  {\n    RuleFor(x => x.Firstname).NotEmpty();\n  }\n}\n")),(0,o.kt)("h2",{id:"command-authorization"},"Command authorization"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},'public class CreateUserCommandAuthorization : ICommandAuthorization<CreateUserCommand>\n{\n  private readonly TestContext _testContext;\n\n  public CreateUserCommandAuthorization(TestContext testContext)\n  {\n    _testContext = testContext;\n  }\n\n  public Task AuthorizeAsync(CreateUserCommand command)\n  {\n    if (_testContext.TenantId == TestContext.TenantAId)\n    {\n        throw Error.Authorization(\n            "TenantUnauthorized",\n            $"Tenant {TestContext.TenantAId} is not allowed to create users");\n    }\n\n    return Task.CompletedTask;\n  }\n}\n')),(0,o.kt)("h2",{id:"command-pre-processing"},"Command pre-processing"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"public class CreateUserCommandPreProcessor : ICommandPreProcessor<CreateUserCommand>\n{\n  public Task ProcessAsync(CreateUserCommand command)\n  {\n    // Pre-processing logic, like checking, if the tenant has enough licenses available, goes here...\n    return Task.CompletedTask;\n  }\n}\n")),(0,o.kt)("h2",{id:"command-post-processing"},"Command post-processing"),(0,o.kt)("h3",{id:"post-process-command-with-result"},"Post-process command with result"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"public class CreateUserCommandPostProcessor : ICommandPostProcessor<CreateUserCommand, User>\n{\n  public Task ProcessAsync(CreateUserCommand command, User result)\n  {\n    // Post-processing logic, like creating a storage container for the user, goes here...\n    return Task.CompletedTask;\n  }\n}\n")),(0,o.kt)("h3",{id:"post-process-command-without-result"},"Post-process command without result"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-csharp"},"public class NotifyUserCommandPostProcessor : ICommandPostProcessor<NotifyUserCommand>\n{\n  public Task ProcessAsync(NotifyUserCommand command)\n  {\n    // Post-processing logic, like creating a storage container for the user, goes here...\n    return Task.CompletedTask;\n  }\n}\n")))}u.isMDXComponent=!0}}]);